// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: google/protobuf/descriptor.proto
package com.google.protobuf

import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.WireField
import kotlin.Any
import kotlin.AssertionError
import kotlin.Boolean
import kotlin.Deprecated
import kotlin.DeprecationLevel
import kotlin.Int
import kotlin.Nothing
import kotlin.String
import kotlin.hashCode
import kotlin.jvm.JvmField
import okio.ByteString

/**
 * ===================================================================
 * Options
 * Each of the definitions above may have "options" attached.  These are
 * just annotations which may cause code to be generated slightly differently
 * or may contain hints for code that manipulates protocol messages.
 *
 * Clients may define custom options as extensions of the *Options messages.
 * These extensions may not yet be known at parsing time, so the parser cannot
 * store the values in them.  Instead it stores them in a field in the *Options
 * message called uninterpreted_option. This field must have the same name
 * across all *Options messages. We then use this field to populate the
 * extensions when we build a descriptor, at which point all protos have been
 * parsed and so all extensions are known.
 *
 * Extension numbers for custom options may be chosen as follows:
 * * For options which will only be used within a single application or
 *   organization, or for experimental options, use field numbers 50000
 *   through 99999.  It is up to you to ensure that you do not use the
 *   same number for multiple options.
 * * For options which will be published and used publicly by multiple
 *   independent entities, e-mail protobuf-global-extension-registry@google.com
 *   to reserve extension numbers. Simply provide your project name (e.g.
 *   Objective-C plugin) and your project website (if available) -- there's no
 *   need to explain how you intend to use them. Usually you only need one
 *   extension number. You can declare multiple options with only one extension
 *   number by putting them in a sub-message. See the Custom Options section of
 *   the docs for examples:
 *   https://developers.google.com/protocol-buffers/docs/proto#options
 *   If this turns out to be popular, a web service will be set up
 *   to automatically assign option numbers.
 */
class FileOptions(
  /**
   * Sets the Java package where classes generated from this .proto will be
   * placed.  By default, the proto package is used, but this is often
   * inappropriate because proto packages do not normally start with backwards
   * domain names.
   */
  @field:WireField(
    tag = 1,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val java_package: String? = null,
  /**
   * If set, all the classes from the .proto file are wrapped in a single
   * outer class with the given name.  This applies to both Proto1
   * (equivalent to the old "--one_java_file" option) and Proto2 (where
   * a .proto always translates to a single class, but you may want to
   * explicitly choose the class name).
   */
  @field:WireField(
    tag = 8,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val java_outer_classname: String? = null,
  /**
   * Sets the Go package where structs generated from this .proto will be
   * placed. If omitted, the Go package will be derived from the following:
   *   - The basename of the package import path, if provided.
   *   - Otherwise, the package statement in the .proto file, if present.
   *   - Otherwise, the basename of the .proto file, without extension.
   */
  @field:WireField(
    tag = 11,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val go_package: String? = null,
  /**
   * Sets the objective c class prefix which is prepended to all objective c
   * generated classes from this .proto. There is no default.
   */
  @field:WireField(
    tag = 36,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val objc_class_prefix: String? = null,
  /**
   * Namespace for generated classes; defaults to the package.
   */
  @field:WireField(
    tag = 37,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val csharp_namespace: String? = null,
  /**
   * By default Swift generators will take the proto package and CamelCase it
   * replacing '.' with underscore and use that to prefix the types/symbols
   * defined. When this options is provided, they will use this value instead
   * to prefix the types/symbols defined.
   */
  @field:WireField(
    tag = 39,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val swift_prefix: String? = null,
  /**
   * Sets the php class prefix which is prepended to all php generated classes
   * from this .proto. Default is empty.
   */
  @field:WireField(
    tag = 40,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val php_class_prefix: String? = null,
  /**
   * Use this option to change the namespace of php generated classes. Default
   * is empty. When this option is empty, the package name will be used for
   * determining the namespace.
   */
  @field:WireField(
    tag = 41,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val php_namespace: String? = null,
  /**
   * Use this option to change the namespace of php generated metadata classes.
   * Default is empty. When this option is empty, the proto file name will be
   * used for determining the namespace.
   */
  @field:WireField(
    tag = 44,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val php_metadata_namespace: String? = null,
  /**
   * Use this option to change the package of ruby generated classes. Default
   * is empty. When this option is not set, the package name will be used for
   * determining the ruby package.
   */
  @field:WireField(
    tag = 45,
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val ruby_package: String? = null,
  unknownFields: ByteString = ByteString.EMPTY
) : Message<FileOptions, Nothing>(ADAPTER, unknownFields) {
  @Deprecated(
    message = "Shouldn't be used in Kotlin",
    level = DeprecationLevel.HIDDEN
  )
  override fun newBuilder(): Nothing = throw AssertionError()

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is FileOptions) return false
    return unknownFields == other.unknownFields
        && java_package == other.java_package
        && java_outer_classname == other.java_outer_classname
        && go_package == other.go_package
        && objc_class_prefix == other.objc_class_prefix
        && csharp_namespace == other.csharp_namespace
        && swift_prefix == other.swift_prefix
        && php_class_prefix == other.php_class_prefix
        && php_namespace == other.php_namespace
        && php_metadata_namespace == other.php_metadata_namespace
        && ruby_package == other.ruby_package
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + java_package.hashCode()
      result = result * 37 + java_outer_classname.hashCode()
      result = result * 37 + go_package.hashCode()
      result = result * 37 + objc_class_prefix.hashCode()
      result = result * 37 + csharp_namespace.hashCode()
      result = result * 37 + swift_prefix.hashCode()
      result = result * 37 + php_class_prefix.hashCode()
      result = result * 37 + php_namespace.hashCode()
      result = result * 37 + php_metadata_namespace.hashCode()
      result = result * 37 + ruby_package.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    if (java_package != null) result += """java_package=$java_package"""
    if (java_outer_classname != null) result += """java_outer_classname=$java_outer_classname"""
    if (go_package != null) result += """go_package=$go_package"""
    if (objc_class_prefix != null) result += """objc_class_prefix=$objc_class_prefix"""
    if (csharp_namespace != null) result += """csharp_namespace=$csharp_namespace"""
    if (swift_prefix != null) result += """swift_prefix=$swift_prefix"""
    if (php_class_prefix != null) result += """php_class_prefix=$php_class_prefix"""
    if (php_namespace != null) result += """php_namespace=$php_namespace"""
    if (php_metadata_namespace != null) result +=
        """php_metadata_namespace=$php_metadata_namespace"""
    if (ruby_package != null) result += """ruby_package=$ruby_package"""
    return result.joinToString(prefix = "FileOptions{", separator = ", ", postfix = "}")
  }

  fun copy(
    java_package: String? = this.java_package,
    java_outer_classname: String? = this.java_outer_classname,
    go_package: String? = this.go_package,
    objc_class_prefix: String? = this.objc_class_prefix,
    csharp_namespace: String? = this.csharp_namespace,
    swift_prefix: String? = this.swift_prefix,
    php_class_prefix: String? = this.php_class_prefix,
    php_namespace: String? = this.php_namespace,
    php_metadata_namespace: String? = this.php_metadata_namespace,
    ruby_package: String? = this.ruby_package,
    unknownFields: ByteString = this.unknownFields
  ): FileOptions = FileOptions(java_package, java_outer_classname, go_package, objc_class_prefix,
      csharp_namespace, swift_prefix, php_class_prefix, php_namespace, php_metadata_namespace,
      ruby_package, unknownFields)

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<FileOptions> = object : ProtoAdapter<FileOptions>(
      FieldEncoding.LENGTH_DELIMITED, 
      FileOptions::class
    ) {
      override fun encodedSize(value: FileOptions): Int = 
        ProtoAdapter.STRING.encodedSizeWithTag(1, value.java_package) +
        ProtoAdapter.STRING.encodedSizeWithTag(8, value.java_outer_classname) +
        ProtoAdapter.STRING.encodedSizeWithTag(11, value.go_package) +
        ProtoAdapter.STRING.encodedSizeWithTag(36, value.objc_class_prefix) +
        ProtoAdapter.STRING.encodedSizeWithTag(37, value.csharp_namespace) +
        ProtoAdapter.STRING.encodedSizeWithTag(39, value.swift_prefix) +
        ProtoAdapter.STRING.encodedSizeWithTag(40, value.php_class_prefix) +
        ProtoAdapter.STRING.encodedSizeWithTag(41, value.php_namespace) +
        ProtoAdapter.STRING.encodedSizeWithTag(44, value.php_metadata_namespace) +
        ProtoAdapter.STRING.encodedSizeWithTag(45, value.ruby_package) +
        value.unknownFields.size

      override fun encode(writer: ProtoWriter, value: FileOptions) {
        ProtoAdapter.STRING.encodeWithTag(writer, 1, value.java_package)
        ProtoAdapter.STRING.encodeWithTag(writer, 8, value.java_outer_classname)
        ProtoAdapter.STRING.encodeWithTag(writer, 11, value.go_package)
        ProtoAdapter.STRING.encodeWithTag(writer, 36, value.objc_class_prefix)
        ProtoAdapter.STRING.encodeWithTag(writer, 37, value.csharp_namespace)
        ProtoAdapter.STRING.encodeWithTag(writer, 39, value.swift_prefix)
        ProtoAdapter.STRING.encodeWithTag(writer, 40, value.php_class_prefix)
        ProtoAdapter.STRING.encodeWithTag(writer, 41, value.php_namespace)
        ProtoAdapter.STRING.encodeWithTag(writer, 44, value.php_metadata_namespace)
        ProtoAdapter.STRING.encodeWithTag(writer, 45, value.ruby_package)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): FileOptions {
        var java_package: String? = null
        var java_outer_classname: String? = null
        var go_package: String? = null
        var objc_class_prefix: String? = null
        var csharp_namespace: String? = null
        var swift_prefix: String? = null
        var php_class_prefix: String? = null
        var php_namespace: String? = null
        var php_metadata_namespace: String? = null
        var ruby_package: String? = null
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> java_package = ProtoAdapter.STRING.decode(reader)
            8 -> java_outer_classname = ProtoAdapter.STRING.decode(reader)
            11 -> go_package = ProtoAdapter.STRING.decode(reader)
            36 -> objc_class_prefix = ProtoAdapter.STRING.decode(reader)
            37 -> csharp_namespace = ProtoAdapter.STRING.decode(reader)
            39 -> swift_prefix = ProtoAdapter.STRING.decode(reader)
            40 -> php_class_prefix = ProtoAdapter.STRING.decode(reader)
            41 -> php_namespace = ProtoAdapter.STRING.decode(reader)
            44 -> php_metadata_namespace = ProtoAdapter.STRING.decode(reader)
            45 -> ruby_package = ProtoAdapter.STRING.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return FileOptions(
          java_package = java_package,
          java_outer_classname = java_outer_classname,
          go_package = go_package,
          objc_class_prefix = objc_class_prefix,
          csharp_namespace = csharp_namespace,
          swift_prefix = swift_prefix,
          php_class_prefix = php_class_prefix,
          php_namespace = php_namespace,
          php_metadata_namespace = php_metadata_namespace,
          ruby_package = ruby_package,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: FileOptions): FileOptions = value.copy(
        unknownFields = ByteString.EMPTY
      )
    }
  }
}
